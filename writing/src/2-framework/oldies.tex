Observe however that LTSs are used in two different ways in this framework. On one hand, they provide a finite (and concrete) representation for infinite (and abstract) sets of traces used to define the semantics of other models. On the other hand, they are (not so) incidentally chosen as a particular representation for agent state machines (even if one could argue that such a representation is too low-level to be of any practical use for end-users). 

We stress this distinction here because, to our opinion, it explains the differences between two different, yet complementary, usages of model synthesis. In some approaches, so-called ``low-level models'' are used to define the semantics or help analyzing other, higher-level models. In this case, the former are used either theoretically as pure mathematical objects or, technically, as synthesized artifacts used as input for model checkers, animators, etc. Whatever the case, low-level models are commonly kept hidden to the end-user, in contrast to the higher-level ones which are used as input language for her (see, e.g.,~\cite{Magee:1997, Uchitel:2003, Damas:2009}). This contrasts with other approaches where different kinds of models are considered on an equal footing to form a consistent, multi-view representation of a system. In this second case, model synthesis aims at enriching the model basis by generating missing models, or completing existing ones. Therefore, synthesized models are visible to the end-user, who is expected to understand their intended meaning in a precise way (see, e.g.,~\cite{VanLamsweerde:1998, Whittle:2000, Uchitel:2004, Damas:2005}).

These two settings are of course complementary, so that the boundary is actually quite fuzzy. This is because providing automated support for a multi-view modeling approach requires formal models, which triggers for a mathematical characterization of their semantics and associated synthesis techniques (of the first kind). In contrast, because the trace semantics is actually very close to the state machines in the multi-view framework studied here, it might look like if the semantics of the other models was defined ``in terms of state machines''. This is, however, at best a shortcut and at worse a logical mistake.

This is of course not saying that scenarios and state machines (say) are not related in some way. In fact, in addition to the model semantics \emph{per se}, this chapter states rules governing their consistent usage for describing a given system. Such inter-model consistency rules are expressed in terms of the formal model semantics, but they are certainly not \emph{the same} as this semantics. In particular, they provide answers to another kind of questions than the aforementioned ones. Examples of such multi-view questions include \emph{is this scenario consistent with those agent state machines?}, \emph{is this safety goal violated by this system?}, \emph{is this scenario an implied one?} Observe that, in a sense, consistency rules give a fulcrum for both model synthesis and model checking (taken in a somewhat different, even broader, sense than usual). Indeed, model checking is applied \emph{against} them, that is, proving their respect or violation, while multi-view model synthesis is applied \emph{towards} them, by synthesizing missing models in a ``correct by construction'' fashion.

