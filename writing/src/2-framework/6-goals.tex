\section{Declarative goals and domain properties\label{section:background-goals}}

A \emph{goal} is a prescriptive statement of intent, whose satisfaction requires the collaboration of agents forming the system. Unlike goals, \emph{domain properties} are descriptive statement about the environment -- such as physical laws, organizational rules, etc. Goals are structured in AND/OR refinement graphs showing how they contribute to each other~\cite{VanLamsweerde:2000}.

Goals and domain properties can be formalized in Linear Temporal Logic (LTL), that allows specifying admissible and/or proscribed system histories in a declarative and implicit way (that is, without requiring an explicit time parameter)~\cite{VanLamsweerde:2009}. In addition to the usual propositional constructs (we ignore first-order constructs here), LTL provides operators for temporal referencing: $\circ$ (at the next smallest time unit), $\diamond$ (some time in the future), $\square$ (always in the future), $\rightarrow$ (implies in the current state), $\Rightarrow$ (always implies), $\mathcal{U}$ (always in the future until), $\mathcal{W}$ (always in the future unless), see~\cite{Manna:1992}.

However, a system history is commonly viewed in LTL as a temporal sequence of system states. Also, atomic propositions of LTL formula often refer to state variables (e.g. in the SPIN model-checker~\cite{Holzmann:1997}). In contrast, a system history is seen as a trace here, that is, a temporal sequence of events. Capitalizing on fluents for reconciling state-based and event-based paradigms (see previous section), we use a flavor of LTL known as Fluent Linear Temporal Logic (FLTL), a linear temporal logic in which atomic propositions are fluents~\cite{Giannakopoulou:2003}. FLTL proves a convenient way for specifying state-based temporal logic properties over the event-based operational model given by our scenarios and state machines. For example, the safety goal ``\emph{Doors shall remain closed while the train is moving}'' of our running example can be formalized in terms of the $Moving$ and $DoorsClosed$ fluents defined in the previous section, as follows:

\begin{center}
\artifact{Maintain[DoorsClosed While Moving]} = $\square(Moving \rightarrow DoorsClosed)$
\end{center}

Properties formalized in temporal logic are often classified as \emph{liveness} or \emph{safety} properties~\cite{Alpern:1986}. The difference between both is generally illustrated with the distinction between ``\emph{something good will eventually happen}'' (liveness) and  ``\emph{something bad never happens}'' (safety). We restrict our attention to safety properties in this thesis. Indeed, reasoning about liveness properties requires considering the acceptance of infinite execution traces, which it ouside the expressiveness of LTSs and regular languages. In contrast, if ``something bad'' happens it must do so after a finite sequence of events, and is irremediable~\cite{Alpern:1986, Giannakopoulou:1999}. Strictly speaking, as with negative scenarios, this is just outside the expressiveness of LTSs, but not of regular languages. Let us explain this by stating the consistency rules first.

\subsubsection*{Multi-view model consistency}

Consider a safety property $G$ and a system $\system$. Let denote by $\mathcal{L}^{-}(G)$ the set of system traces that violates the property. We say that the system respects the property, that is that they are consistent if and only if the following condition holds:

\begin{center}
$\mathcal{L}(Ag_1 \parallel \ldots \parallel Ag_n) \cap \mathcal{L}^{-}(G) = \emptyset$
\end{center}

The equation above simply requires the system not to exhibit traces that violate the safety property. In fact, it is the well known one from model checking~\cite{Clarke:1989}, provided that $\mathcal{L}^{-}(G)$ actually is $\mathcal{L}(\neg G)$, that is the set of traces that satisfy the negation of the safety property.

\subsection{Tester and property automata}

It it straightforward to check that $\mathcal{L}^{-}(G)$ cannot be represented with a pure LTS, because it is not prefix-closed. For example, the trace \artifact{<start alarm open>} certainly violates the safety goal for the train and so, belongs to $\mathcal{L}^{-}(Maintain[DoorsClosed While Moving])$, but \artifact{<start alarm>} does not violate it (yet). However, as a safety property can only be violated after a finite trace and remains violated after that, $\mathcal{L}^{-}(G)$ is suffix-closed. Let contrast this with $\mathcal{L}^{+}(G)$ that denotes the set of all possible system traces that do \emph{not} violate the property. This language certainly includes all traces that, at one event near, do not violate the property; it also includes all their prefixes, but not all their suffixes. That is, $\mathcal{L}^{+}(G)$ is prefix-closed, and can be represented by a LTS. 

In fact, $\mathcal{L}^{-}(G)$ and $\mathcal{L}^{+}(G)$ are \emph{complement} of each other. That is, $\mathcal{L}^{+}(G) = \Sigma^{*} \setminus \mathcal{L}^{-}(G)$. Interestingly, the complement of a regular language is also a regular language~\cite{Hopcroft:1979}, which implies that both can be modeled with standard automata. In contrast, the complement of a prefix-closed language is not prefix-closed, as we have illustrated on the example. Complementing a language is straightforward when represented 


