\section{Model synthesis revisited\label{section:background-discussion}}

We close this chapter with an overview of existing model synthesis techniques and opportunities offered by the framework defined here. Model synthesis outside the boundaries of the present framework is discussed in chapter~\ref{chapter:discussion}.

As stated earlier, the term ``model synthesis'' can be interpreted differently according to the objectives behind its use. In particular, we have already made a distinction between analysis-driven synthesis and multi-view model synthesis. In the first, synthesized models are for the \emph{machine}, and are typically used by a model-checker, an animator, a code generator, and so on. If not hidden to the end-user, their primary intent is not to be manipulated by her. In the second, models are for \emph{humans} and are used for thinking about, designing or documenting a system. Synthesized models aim at completing a multi-view system description, at semi-automatically validating it with the user, or both. Here, therefore, models are intended to be shown to users and understood by them.

We have said that the distinction between both is fuzzy. The reason is that analysis-driven synthesis proves useful for supporting a user-oriented completion and/or validation of multi-view system descriptions. A model-checker, for example, can be used to check the consistency between a safety goal and, say, a hMSC. However, the counter-example it generates can effectively been used to enrich the scenario description with a negative scenario illustrating the violation of the goal. Looking at model-checker internals shows analysis-driven synthesis techniques (e.g., from hMSC to LTS), while looking at its use -- maybe hidden use -- for helping building complete and consistent models shows multi-view synthesis techniques. We shortly describe additional examples of both kinds below.

TODO: add a note about the fact that analysis-driven synthesis is (seems?) necessarily deductive, while some kind of induction is often used in multi-view synthesis.

\subsection*{Analysis-driven synthesis}

The technique from \cite{Uchitel:2003}, presented in section~\ref{section:background-hmsc}, can be interpreted as synthesizing agent state machines from a hMSC. However, the technique is entirely deductive; it generates a minimal LTS for each agent, that is, a state machine that precisely captures the agent traces defined in the hMSC. Of course, inter-model consistency rules between the hMSC and generated state machines are respected by construction.  The authors' motivation is to be able to model-check or animate a hMSC specification. In that sense, state machines are not intended to be seen or manipulated directly by the end-user.

In chapter~\ref{chapter:deductive} of the present thesis, we extend our framework with guarded process models. The latter take the form of hMSCs to which decision nodes are added and we provide a declarative trace-based semantics for such models. The chapter also describes a synthesis algorithm for computing accepted traces as a LTS. This algorithm enables reusing a trace-based model-checker ala LTSA~\cite{Magee:1999} for guarded models.

\subsection*{Multi-view model synthesis}

In \cite{Uchitel:2004}, Uchitel explains how implied scenarios can be used to validate a hMSC specification, say $H$, with experts. Implied scenarios are all traces in $\mathcal{L}_{arch}(H) \setminus \mathcal{L}_{weak}(H)$, that is, scenarios that are not explicitly described in the hMSC, but that will necessarily be accepted in any system consistent with it. These scenarios are enumerated and submitted for classification as positive or negative by an expert. This allows to semi-automatically check the consistency between the system description given by the hMSC and the system composed of the agent state machines generated by the technique aforementioned \cite{Uchitel:2003}. As a notable side effect, classified scenarios enrich the initial scenario description. However, by definition, an implied scenario classified as negative hurts inter-model consistency, as it should be rejected by the system but could not be. In general, negative implied scenarios are a sign that agents and their interfaces should be refactored. 

A technique for synthesizing goals from a scenario collection is presented in~\cite{Damas:2006}. It consist in decorating MSC timelines with invariants on fluents monitored and controlled by the associated agent. From these invariants, goals are induced that respect two kinds of specification patterns, namely \emph{maintain goals} $\square(P \rightarrow Q)$ and \emph{immediate achieve goals} $\square(P \rightarrow \circ Q)$. Here also, inferred goals are submitted for classification by an expert. Accepted goals enrich the goal model while rejected ones call for enriching the scenario collection with a counter example. Thus, the technique helps enriching a multi-view system description while guaranteeing consistency. As it mostly relies on the availability of fluent invariants, the technique could be extended to infer goals from any annotated LTS, and hence, from agent state machines or a hMSC. 

In chapter~\ref{chapter:inductive-synthesis} of the present thesis, we describe an inductive technique for synthesizing agent state machines from scenario collections and hMSCs. Unlike \cite{Uchitel:2003} inferred models cover more behaviors than the hMSC. Also, information offered by the other models (fluents, goals, etc.) is used to guarantee inter-model consistency. The generalization process is guided by the end-user who is requested to classify additional scenarios as positive or negative system behaviors.  
