\chapter{A multi-view modeling framework\label{chapter:framework}}

This chapter installs the background necessary for understanding subsequent chapters of this thesis. 


\newcommand{\artifact}[1]{\texttt{#1}}

\section{Agents, System and their Behavior}

A system -- both the software-to-be and its environment -- is commonly admitted to be made of active components, that we call \emph{agents}. Agents behave and interact so as to fulfill system goals while restricting their behavior to ensure constraints they are assigned to~\cite{Feather:1987}. In the early design phase of a system, we are mostly concerned with interactions between agents -- the way they collaborate to form the system -- in contrast to their respective internal implementation. In other words, and from a single agent perspective, we mainly focus on the agent behaviors that are observable by its environment. In this thesis, we choose to model such behaviors and interactions in an event-based framework where agents communicate via messages that are sent and received instantaneously. Such kind of communication, called \emph{handshaking} communication, leads to a \emph{synchronous} event-based framework. The choice of a synchronous event-based framework is motivated by its simplicity, an important aspect for accessibility to stakeholders involved during the early-design phase of a system.

\subsection{Agents as Labeled Transition Systems}

In our framework, the behavior of an agent, say \artifact{Ag}, is modeled by a specific kind of finite state machine, called \emph{labeled transition system} (LTS). This formalism, initially introduced by Keller for reasoning about parallel programs~\cite{Keller:1976}, has since been intensively used for specifying and analyzing concurrent systems, e.g. in~\cite{Milner:1989, Clarke:1989, Magee:1997}. A LTS is made of a set of states and a set of transitions between them (see Fig.\ref{image:framework-start-stop}). Each transition is labeled with an \emph{event} name -- sometimes called an \emph{action} name; also, a specific state is the \emph{initial state}, designated graphically by an empty arrow in front of it (state 0 in the figure).

\begin{figure}[H]
\centering\scalebox{0.8}{
  \includegraphics*{src/2-framework/images/start-stop}}
  \caption{A Labeled Transition System for an \artifact{Engine} agent\label{image:framework-start-stop}.}
\end{figure}

The \emph{alphabet} of an agent, denoted by $\Sigma(\artifact{Ag})$ (or $\Sigma$ for short if the agent is clear),  denotes the set of event names that the agent recognizes. At first glance, therefore, the alphabet of an agent is composed of the different labels depicted on its LTS. In the example at hand, \artifact{$\Sigma(\artifact{Engine})=\{start, stop\}$}. The alphabet captures the notion of \emph{agent interface}, as a set of observable events, and naturally drives the way the agent interacts with its environment (see the notion of agent composition later).

By definition in this thesis, the \emph{behavior} of an agent is the (infinite) set of finite traces that its LTS accepts. It is also called its \emph{language} and will be noted $\mathcal{L}(Ag)$. A trace is a sequence of event names, and will be written between \verb|<| and \verb|>| brackets. Loosely speaking, a trace is accepted by a LTS if it denotes an existing path in the corresponding graph, starting in the initial state. Note that, by this definition, a prefix of an accepted trace is also an accepted trace; the empty trace $\lambda$ is therefore always accepted. For example, the LTS of Fig.\ref{image:framework-start-stop} accepts the trace \artifact{<start stop start>}, and hence \artifact{<start stop>}, but not \artifact{<start start>}. The corresponding \emph{language} is $\mathcal{L}(\artifact{Engine})=\{\lambda$, \artifact{<start>}, \artifact{<start stop>}, \artifact{<start stop start>}, \ldots $\}$

Now, if an agent and its behavior -- as traces admitted by its LTS -- are conceptually two different things, we are almost exclusively concerned here with behavioral aspects of agents. For this reason and unless the context demands making a clear distinction, we'll often use the term \emph{agent} to actually denote its LTS. Similarly, we'll often use the term \emph{alphabet} (or \emph{language}) of a LTS directly. The formal definitions given later support us in doing so.

Last, but not least, we assume \emph{deterministic} agents in this thesis, and strongly rely -- yet sometimes subtly -- on this hypothesis. This choice allows keeping our modeling framework conceptually simple to use and intuitive for stakeholders involved in the early design phase that our techniques target. From a conceptual point of view, such an assumption means that the state of an agent at a given time is uniquely determined by the sequence of events it has ``processed'' from its initial state. It also means that the agent will react to subsequent events on a pre-defined and known way, that does not depend on non-observable phenomena that happened in the past or could happen in the future (in other words, everything necessary to distinguish between two different agent states is explicitly modeled). An agent is deterministic if and only if its LTS is itself deterministic. A LTS is deterministic if no state has two outgoing transitions labeled with the same event name and does not make use of non-observable transitions -- so-called $\tau$ transitions. Note that many authors use more complex frameworks for specifying and verifying concurrent and/or distributed systems. In particular, the related literature on process algebra does not make a deterministic assumption similar to ours, see e.g. \cite{Hoare:1985}, \cite{Milner:1989} and \cite{Magee:1999}.

This deterministic assumption has important consequences on our framework, and on the soundness of our synthesis techniques. In particular, two states of an LTS (resp. two LTS) may safely be considered equivalent if they accept the same set of traces (resp. they accept the same set of traces from their respective initial state), which is known as defining a \emph{trace equivalence} binary relation on LTS states. This choice justifies our definition of an agent behavior in terms of the language it accepts. In particular we can safely restrict our attention to agent behaviors defined by the class of \emph{regular} languages~\cite{Hopcroft:1979}, a necessary hypothesis for inductive behavior synthesis presented in chapter~\ref{chapter:inductive-synthesis}. Note that regular languages are also assumed by authors that rely on scenarios for modeling and/or verifying concurrent systems, see e.g.~\cite{Alur:1999, Uchitel:2003, Uchitel:2004}.

\subsection{System as Agent composition}

If a system is composed of active agents and the behavior of each of these agent is explicitly modeled with an LTS, one can ask what is the behavior of the system itself. We define it through parallel composition~\cite{Hoare:1985}, by capturing the set of traces of agents executing asynchronously but synchronizing on all shared event names. Given a system made of $n$ agents, and a composition operator denoted by~$||$, the system is defined as:

\begin{center}
$System = Ag_1~||~...~||~Ag_n$ 
\end{center}

Restricting here to agent \emph{behaviors} only, we use the binary composition operator $||$ on LTS (the operator is both commutative and associative, allowing our writing above). Let assume two agents whose LTS are $P$ and $Q$ respectively. The composition $P~||~Q$ is another LTS whose state space is defined on the Cartesian product of the states of $P$ and $Q$. That is, a state $(P_i,Q_i)$ models the fact that the first agent is in state~$i$ and the other in state~$j$. From the interleaving semantics, in such a state either both agents transit on a shared event.

%\begin{definition}[Labeled Transition System]
%A labeled transition system is a 4-tuple $(Q,\Sigma,\delta,q_0)$ where $Q$ is a finite set of states, $\Sigma$ is a set of event names n alphabet, $\delta$ is a transition function mapping $Q\times\Sigma$ to $2^Q$ and $q_0$ is the initial state. The LTS is said to be \emph{deterministic} if for any $q$ in Q and any $e$ in $\Sigma$, $\delta(q,e)$ has at most one member. 
%\end{definition}


