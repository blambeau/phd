\chapter{A multi-view modeling framework\label{chapter:framework}}

This chapter installs the necessary background about the formalisms we use and sets up our multi-view modeling framework. That is, we've decided to present the technical background \emph{in situ}. Indeed, strictly speaking, the multi-view framework is a contribution of this thesis; but almost all its technical pieces -- formalisms, algorithms and techniques -- are not. Presenting them together, however, allows us to explain and reconcile two related but different visions of model synthesis.

The framework and these two visions are illustrated in Fig. \ref{image:framework}, that also provides a key for reading this chapter. As shown, the semantics of our models is grounded on classical \emph{trace theory}~\cite{Hoare:1985}. A \emph{trace} is a finite sequence of symbols, a simple abstraction commonly used to capture the notion of ``observable behavior'' in the context of concurrent systems. In our case, the notion of behavior actually denotes interactions among agents forming a system, modeled as \emph{events} sent and received by agents in a synchronous fashion. A (possibly infinite) set of traces, also called a \emph{language}, is typically captured with a kind of automaton named a labeled transition system (LTS).

This trace-based setting is complemented with \emph{fluents}, that capture state-based propositions in terms of the occurrence of events. Among others, fluents provide a friendly interface between event-based models (e.g. scenarios and state machines) and state-based models (e.g. goals and domain properties). This mix of event-based and state-based abstractions provide a precise meaning, consistent \emph{semantics}, to all models used in this thesis. 

\begin{figure}[t]\centering
  \scalebox{0.55}{\includegraphics[trim=2mm 2mm 2mm 2mm, clip]{src/2-framework/images/framework}}
  \caption{Semantics and Multi-View consistency in our formal framework.\label{image:framework}}
\end{figure}

Observe however that LTSs are used in two different ways in this framework. On one hand, they provide a finite (and concrete) representation of infinite (and more abstract) sets of traces used to define the semantics of other models. On the other hand, they are incidentally chosen as a particular representation for agent and system state machines (even if one could argue that such a representation is too low-level to be of any practical use for end-users). 

We stress this distinction here because it explains the differences between two different, yet complementary, usages of models and their synthesis. In some approaches, so-called ``low-level models'' are used to define the semantics or help analyzing other, higher-level models. In this case, the former are used either theoretically as purely mathematical objects or, technically, as synthesized artifacts used as input for model checkers, animators, etc. Whatever the case, low-level models are commonly kept hidden to end-users, in contrast to the higher-level ones which are used as input language for them (see, e.g.,~\cite{Magee:1997, Uchitel:2003, Damas:2009}). In other approaches, different kinds of models are considered on an equal footing, and one would like to obtain a consistent, multi-view representation of a system. In this second case, model synthesis aims at enriching the latter by generating missing models, or completing existing ones. Here, synthesized models are then visible to the user, who is expected to understand their intended meaning in a somewhat precise way (see, e.g.,~\cite{VanLamsweerde:1998, Whittle:2000, Uchitel:2004, Damas:2005}).

These two settings are complementary. Indeed, providing automated support to the second, multi-view modeling approach, requires models to be grounded on a common formal framework. This triggers for a mathematical characterization of their semantics and associated synthesis techniques. This is the intended meaning of arrows labeled ``synthesis-driven semantics'' in Fig.\ref{image:framework}. Also, multi-view modeling triggers for the definition of inter-model rules governing their consistent usage. These rules are related, even expressed in terms of the formal model semantics, but certainly different from the latter \emph{per se}. Synthesis-driven semantics is both used \emph{against} inter-model consistency rules, to verify them or prove their violation through a counter example (model-checking is worth noting here) and \emph{towards} them by synthesizing missing model views in a ``correct by construction'' fashion (see chapter~\ref{chapter:inductive-synthesis} for example).

The rest of this chapter is organized as follows. After a short description of our running example in the next section, Section~\ref{XX} provides background on trace semantics and labeled transition systems. Section~\ref{XX} then explains how the latter can be used as simple state machines to model agent behaviors and their composition. The trace semantics of scenarios and how they fit with state machines is detailed in section~\ref{XX}. We then turn to state based abstractions by describing fluents and their use in state invariants in Section~\ref{XX}, and goals and domain properties in Section~\ref{XX}. We close this chapter with a discussion in Section~\ref{XX}. 

\input{src/2-framework/running-example}
\input{src/2-framework/agents}
\input{src/2-framework/scenarios}

\section{State-based invariants through Fluents}

\subsection{Decorating LTS with invariants}

\section{Declarative goals and domain properties}

\section{Discussion\label{section:background-discussion}}
