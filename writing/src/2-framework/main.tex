\chapter{A multi-view modeling framework\label{chapter:framework}}

This chapter installs the necessary background about the formalisms we use and, at the same time, sets up our multi-view modeling framework. That is, we've decided to present the technical background \emph{in situ}. Indeed, strictly speaking, the multi-view framework is a contribution of this thesis; but almost all its technical pieces -- formalisms, algorithms and techniques -- are not. Presenting both together allows us to explain the logical separation that has to be made between the \emph{semantics} of the models we use (scenarios, state machines, etc.) and the rules that govern their \emph{consistent usage} for modeling. 

The framework and the separation aformentioned are illustrated in Fig. \ref{image:framework}, that also provides a key for reading this chapter. As shown in the middle, the mathematical theory on which relies the semantics of our models is the classical \emph{trace theory}~\cite{Hoare:1985}. A \emph{trace} is a finite sequence of symbols and an abstraction commonly used to capture the notion of ``observable behavior'' in the context of concurrent systems. A (possibly infinite) set of such traces, sometimes called a \emph{language}, is commonly modeled with a kind of automaton called labeled transition systems (LTS)~\cite{Keller:1976, Clarke:1989, Milner:1989}. In our case, the notion of behavior actually denotes interactions among agents forming a system. Such interactions are modeled as \emph{events} that are synchronously sent and received by agents. Therefore, here a trace captures a sequence of such events, identified by their label. We mostly treat the terms ``symbol'' and ``event label'' (or ``event'' for short unless precision is necessary) as synonyms but use the latter term inside the framework while the former is kept for more abstract contexts.

The trace-based theory is complemented with \emph{fluents}, that capture state-based propositions in terms of the occurence of events. Among others, fluents provide a friendly interface between event-based models (e.g. scenarios and LTS state machines) and state-based models (e.g. goals and domain properties). This mix of event-based and state-based abstractions provide a precise meaning, consistent \emph{semantics}, to all models used in this thesis. 

Howeber, observe that LTSs are actually used in two different ways in this framework. On one hand, they provide a finite (and concrete) representation of infinite (and more abstract) sets of traces. In that sense, their usage is either purely theoretical or strictely technical, that is, it is kept hidden from the end-user inside the framework (or even its definition). On the other hand, they are incidentally chosen as the particular representation of agent and system state machines. In that sense, their use is practical and visible to the user (even if one could argue that such a representation is too low-level to be of any practical use). 

\begin{figure}[t]\centering
\scalebox{0.55}{
  \includegraphics[trim=2mm 2mm 2mm 2mm, clip]{src/2-framework/images/framework}
}
\caption{Semantics and Multi-View consistency in our formal framework.\label{image:framework}}
\end{figure}

Making this distinction naturally leads to make another one, between the \emph{semantics} of the models and the rules that govern their \emph{consistent usage} for modeling. This distinction, even if an important one, is often left implicit in the literature about modeling synthesis, including our own publications. The reason is simply that in most approaches, an (unexisting) \emph{target} model (typically, state machines) is synthesized from an already existing one (typically, scenarios) and consistency rules between them (sometimes made explicit through additional annotations asked to the user), see e.g.~\cite{Uchitel:2003, Damas:2005, Whittle:2000}. In this context, a shortcut is often made that consists in explaining (or even defining the semantics of) one model in terms of the abstractions found in the other one (e.g. a scenario \emph{is} a path in the directed graph defined by a state machine) thanks to the consistency rules. In most case, the latter rely on a sound semantics shared between the two models -- allowing the synthesis process to be (semi-)automated -- but they are not the semantics \emph{per se}. 

We adopt another approach in the multi-view framework described here. Indeed, all models -- including agent state machines -- are first defined on an equal footing, in terms of traces, regarless of their joint use for modeling a system. In addition, we state a (non exhaustive) list of inter-model consistency rules that precisely state the conditions under which two models ``agree'' on the modeling of the same system. In our context, therefore, \emph{model synthesis} aims at completing a system description by deriving certain models thanks to the information provided by others; this process is done \emph{via} their inter-model consistency rules and using their common formal semantics as a deductive or inductive axiomatic system. This contrast with \emph{model checking} -- taken in a somewhat different, actually broader, sense than usual here -- that aims at verifying the consistency of multi-model system descriptions; this process is done \emph{against} their inter-model consistency rules while their common formal semantics is used as an axiomatic system for proving their respect or demonstrating their violation.

\input{src/2-framework/running-example}
\input{src/2-framework/agents}
\input{src/2-framework/scenarios}

\section{State-based invariants through Fluents}

\subsection{Decorating LTS with invariants}

\section{Declarative goals and domain properties}

\section{Discussion\label{section:background-discussion}}
