\chapter{A multi-view modeling framework\label{chapter:framework}}

This chapter installs the necessary background about the formalisms we use and sets up our multi-view modeling framework. That is, we've decided to present the technical background \emph{in situ}. Indeed, strictly speaking, the multi-view framework is a contribution of this thesis, but almost all its technical pieces -- formalisms, algorithms and techniques -- are not. Presenting them together, however, allows us to explain and reconcile two related but different usages of model synthesis.

The framework is illustrated in Fig. \ref{image:framework}, that also provides a key for reading this chapter. As shown, the semantics of our models is grounded on standard \emph{trace theory}~\cite{Hoare:1985}. A \emph{trace} is a finite sequence of symbols, a simple abstraction commonly used to capture the notion of ``observable behavior'' in the context of concurrent systems. In our case, the notion of behavior actually denotes interactions among agents forming a system. These interactions are modeled as \emph{events} sent and received by agents in a synchronous fashion. The (possibly infinite) set of traces that an agent or the system can exhibit, is captured with a kind of automata called labeled transition systems (LTS).

This trace-based setting is complemented with \emph{fluents}, that capture state-based propositions in terms of the occurrence of events. Among others, fluents provide a friendly interface between event-based models (e.g. scenarios and state machines) and state-based models (e.g. goals and domain properties). This mix of event-based and state-based abstractions provide a precise meaning, consistent \emph{semantics}, to all models used in this thesis. This semantics gives precise answers to questions like \emph{what traces does a scenario define?}, \emph{is this trace accepted by this state machine?}, \emph{does this sequence of events violate this safety goal?}, and so on.

\begin{figure}[t]\centering
  \scalebox{0.50}{\includegraphics[trim=2mm 2mm 3mm 2mm, clip]{src/2-framework/images/framework}}
  \caption{Semantics and Multi-View consistency in our formal framework.\label{image:framework}}
\end{figure}

Observe however that LTSs are used in two different ways in this framework. On one hand, they provide a finite (and concrete) representation for infinite (and abstract) sets of traces used to define the semantics of other models. On the other hand, they are (not so) incidentally chosen as a particular representation for agent state machines (even if one could argue that such a representation is too low-level to be of any practical use for end-users). 

We stress this distinction here because, to our opinion, it explains the differences between two different, yet complementary, usages of model synthesis. In some approaches, so-called ``low-level models'' are used to define the semantics or help analyzing other, higher-level models. In this case, the former are used either theoretically as pure mathematical objects or, technically, as synthesized artifacts used as input for model checkers, animators, etc. Whatever the case, low-level models are commonly kept hidden to the end-user, in contrast to the higher-level ones which are used as input language for her (see, e.g.,~\cite{Magee:1997, Uchitel:2003, Damas:2009}). This contrasts with other approaches where different kinds of models are considered on an equal footing to form a consistent, multi-view representation of a system. In this second case, model synthesis aims at enriching the model basis by generating missing models, or completing existing ones. Therefore, synthesized models are visible to the end-user, who is expected to understand their intended meaning in a precise way (see, e.g.,~\cite{VanLamsweerde:1998, Whittle:2000, Uchitel:2004, Damas:2005}).

These two settings are of course complementary, so that the boundary is actually quite fuzzy. This is because providing automated support for a multi-view modeling approach requires formal models, which triggers for a mathematical characterization of their semantics and associated synthesis techniques (of the first kind). In contrast, because the trace semantics is actually very close to the state machines in the multi-view framework studied here, it might look like if the semantics of the other models was defined ``in terms of state machines''. This is, however, at best a shortcut and at worse a logical mistake.

This is of course not saying that scenarios and state machines (say) are not related in some way. In fact, in addition to the model semantics \emph{per se}, this chapter states rules governing their consistent usage for describing a given system. Such inter-model consistency rules are expressed in terms of the formal model semantics, but they are certainly not \emph{the same} as this semantics. In particular, they provide answers to another kind of questions than the aforementioned ones. Examples of such multi-view questions include \emph{is this scenario consistent with those agent state machines?}, \emph{is this safety goal violated by this system?}, \emph{is this scenario an implied one?} Observe that, in a sense, consistency rules give a fulcrum for both model synthesis and model checking (taken in a somewhat different, even broader, sense than usual). Indeed, model checking is applied \emph{against} them, that is, proving their respect or violation, while multi-view model synthesis is applied \emph{towards} them, by synthesizing missing models in a ``correct by construction'' fashion.

The rest of this chapter is organized as follows. The running example used throughout this thesis is quickly presented in the next section. Section~\ref{section:background-agents-system-behaviors} then provides background on trace semantics and labeled transition systems \emph{in situ}, that is, through their usage for modeling agent and system behaviors as state machines. The trace semantics of scenarios and how they fit with LTS state machines is detailed in section~\ref{section:background-scenarios}. We then turn to state based abstractions by describing fluents and their use for capturing LTS state invariants in Section~\ref{section:background-fluents}, and goals and domain properties in Section~\ref{section:background-goals}. We close this chapter with a discussion in Section~\ref{section:background-discussion}. 

\input{src/2-framework/1-running-example}
\input{src/2-framework/2-agents}
\input{src/2-framework/3-scenarios}
\input{src/2-framework/4-fluents}
\input{src/2-framework/5-goals}
\input{src/2-framework/6-discussion}
