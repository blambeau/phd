\chapter{Inductive Synthesis of State Machines from Scenarios\label{chapter:inductive-synthesis}}

This chapter presents an inductive approach for synthesizing state machines from scenarios. Section~\ref{section:inductive-objectives-and-approach} characterizes the problem, discusses a few requirements and provides an overview of our solution. Section~\ref{section:inductive-background} provides some required background on grammar induction, the inductive framework on which our techniques are rooted \cite{Gold:1978}. Section~\ref{section:lts-induction-from-mscs} describes an interactive technique for learning LTS models from collections of MSCs. This technique is interactive; the end-user is expected to classify additional scenarios generated by the technique as positive and negative examples of system behavior. In Section~\ref{section:inductive-mutliview-consistency}, fluent, goals and domain properties are injected in the process to enforce inter-model consistency and prune the inductive search space for better performance. Section \ref{section:inductive-from-hMSC} discusses how hMSCs can be used as richer input of the synthesis process.

\input{src/4-inductive/1-objectives-and-approach}
\input{src/4-inductive/2-grammar-induction-for-lts-synthesis}
\input{src/4-inductive/3-interactive}
\input{src/4-inductive/4-injecting-constraints}
\input{src/4-inductive/5-induction-from-hmsc}
\input{src/4-inductive/6-correctness}
\input{src/4-inductive/7-discussion}

\section*{Summary}

This chapter discussed how grammar induction may be used to synthesize LTS state machines from end-user scenarios. The RPNI induction algorithm provides a basis to generalize scenario behaviors as a system LTS; the latter is then projected on the alphabet of each agent to obtain their state machines. 

QSM extends RPNI with an interactive feature where an end-user classifies generated scenarios as positive or negative examples of desired system behavior. This constrains the induction process towards good behavior generalizations. It also allows completing the initial scenario collection with interresting agent interactions that were not initially explored.

QSM and ASM may be constrained through equivalence relations defined on system states. This mechanism has been instantiated to prune the induction process with the definition of fluent state variables, models of legacy components, domain properties, and goals. In addition to guaranteeing multi-view model consistency, the injection of such knowledge offers better induction performance and reduces the number of user interactions.

Structured forms of scenario descriptions, such as hMSCs, prove useful for large systems. Among others, they overcome a limitation when using scenario collections in practice, namely, the requirement that all scenarios start in the same system state. The induction of agent state machines from hMSC scenarios has been shown possible thanks to the ASM algorithm. 

While our current ASM implementation is rather limited, the chapter has shown that the design of an induction algorithm mixing hMSC input, scenario questions and injection of domain knowledge and goals raises only minor issues. 

This transition from RPNI/QSM to ASM actually raises interesting perspectives for future research. Indeed, from a grammar induction standpoint, this amounts to generalize a positive language under the control of a negative one. Such problem does not exactly fit in the identification-in-the-limit framework; in particular, the convergence criteria needs to be revisited. From the software engineering standpoint, we are confident that such work would set a sound basis for tackling the synthesis of behavior models from structured forms of scenarios and safety properties.
