\section{Models and their use for software systems}

Models are increasingly recognized as an effective means for elaborating requirements and exploring designs of software systems. A model is an abstract representation of the target system, where key features are highlighted, specified and inter-related to each other \cite{VanLamsweerde:2009}. Models are widely used at different steps of the software development process and for different software-related purposes.

%%%

\emph{Requirements engineering} for example, aims at deciding precisely what the system should do. It has been claimed that this is the hardest part of software development \cite{Brooks:1987}. Using models for exploring and stating requirements has multiple benefits:
\begin{itemize}
\item They force stakeholders and analysts to be more precise in their system description.
\item They allow them to abstract from multiple details in order to focus on key system aspects.
\item They provide a basis for early detection and fixing of errors.
\end{itemize}
Model-oriented approaches to system requirements include KAOS \cite{VanLamsweerde:2009} and NFR/i$^*$ \cite{Mylopoulos:1992, Yu:1993}. Models explain how system objectives may be refined in lower-level objectives, also called goals. KAOS emphasizes more on semi-formal and formal reasoning about behavioral goals, i.e. goals that prescribe system behaviors declaratively. In NFR/i$^*$, the emphasis is more on qualitative reasoning on soft goals, i.e. goals that cannot be established in a clear-cut sense.

%%%

\emph{Software design} may be captured by Model Driven Engineering (MDE) approaches and driven by UML models \cite{OMG:2004} and Domain Specific Languages \cite{VanDeursen:2000, Fowler:2010}. Such approaches model the application domain rather than the computing or algorithmic concepts. The use of models here has several advantages:
\begin{itemize}
\item They enforce the separation between the abstract domain concepts and their concrete implementation. This allows focusing on each aspect at the adequate level of abstraction.
\item Code fragments can often be generated from models, which is less error-prone and time consuming than manually translating models to code. In the case of domain specific languages, models may even be truly executable already. 
\item Design models also yield a natural documentation for the software and the underlying design decisions. 
\end{itemize}

%%%

\emph{Work processes} may be represented by different graphical models. Such models take different forms: flowchart style, e.g. Activity Diagrams \cite{OMG:2004}, YAWL \cite{Vanderaalst:2005} or Business Process Modeling Notation (BPMN) \cite{OMG:2008}, task trees, e.g. Little-Jil \cite{Clarke:2008}. Modeling here allows:
\begin{itemize}
\item Analyzing and verifying models before translating them to work organization on the field. This includes early detecting errors and bottlenecks, among others.
\item Partly or fully triggering the execution of necessary tasks, through reminders to process actors, automated scheduling and task processing, and so on.
\end{itemize}

\section{Requirements on multi-view modeling languages}

Complex systems are better described with multiple views. In that case, different models focus on particular facets of the system, i.e. its intentional, structural, operational and behavioral dimensions \cite{VanLamsweerde:2009}. 

Scenarios, for example, illustrate typical interactions between agents whereas their state machines provide a complete description of their internal behavior. A process model might describe the operational decomposition of a complex work into smaller tasks whereas goals make the underlying objectives precise. And so on.

Reaching quality models in such multi-view approaches is far from an easy task. Adequate modeling languages, tools and techniques are therefore required to help building them. To play a significant role, a good multi-view modeling language should meet the following requirements \cite{VanLamsweerde:2009}:

\begin{itemize}
\item \emph{Multi-level}: the system should be captured at different levels of abstraction and precision to enable stepwise elaboration and validation;
\item \emph{Analyzable}: the modeling abstractions should be accurate enough to support useful forms of analysis.
\end{itemize}

In addition, such modeling language should support stakeholders and analysts in building quality models. A ``good'' model should meet the following requirements:

\begin{itemize}
\item \emph{Adequate}: the models should adequately represent the essence of the target system while abstracting unnecessary details;
\item \emph{Complete}: the models should capture all pertinent facets of the system along the \textsc{why-}, \textsc{what-} and \textsc{how-} dimensions;
\item \emph{Precise}: the models should be accurate enough to capture system descriptions with as less ambiguity as possible;
\item \emph{Consistent}: the models should agree on their overlapping descriptions of the system;
\item \emph{Comprehensible}: the models should be easy enough to understand by the people who need to use them;
\end{itemize}

Formal modeling approaches help meeting the requirements above. The semantics of a formal modeling language provides precise rules of interpretation that allow many of the problems with natural language to be overcome. Formal specifications may also be manipulated by automated tools for a wide variety of purposes. Among them, model \emph{analysis} and model \emph{synthesis} are intertwined activities that help reaching quality models, mostly along the completeness, consistency and precision requirements.

This thesis investigates model synthesis more specifically whereas its companion one, by Christophe Damas, investigates model analysis \cite{Damas:2011}.

\section{Synthesis for multi-view system modeling}

Roughly, model synthesis can be seen as the systematic construction of models from various sources of knowledge about the target system. 

Common sources of knowledge for building models include early system descriptions, interviews with stakeholders, software prototypes, etc. For an in-depth description of requirements elicitation and system modeling from such sources see, e.g., \cite{VanLamsweerde:2009}.

Multi-view modeling frameworks offer new ways for effectively supporting the incremental building of models. In particular, formal modeling languages define precise consistency rules between models. These rules are commonly used to automate consistency verification and/or model checking. Those same rules can also be used the other way around, that is, to semi-automatically synthesize some models using the information already made available by the others.

The use of a synthesis technique, however, may be motivated by various needs. As a consequence, the term ``model synthesis'' actually covers a broad spectrum of techniques and practices. In this thesis, we will distinguish between two particular and complementary use cases:
\begin{itemize}
\item Model synthesis can be used to define an operational semantics for high-level models in terms of lower-level ones. This also allows making analysis such as model-checking available to high-level models while initially available on lower-level ones.
\item Model synthesis can also be used to complete a multi-view modeling of the target system. A synthesis technique is used here to build missing models from a multi-view framework or to complete existing ones.
\end{itemize}

While the construction of models is involved in both cases, observe that these two uses of model synthesis are rather different.
\begin{itemize}
\item When defining an operational semantics, the synthesized models are generally defined at a lower-level of abstraction than the source models they come from; this is not necessarily true when completing multi-view models, quite the contrary.
\item When used for triggering analyses, produced models have a short lifetime, generally limited to the analysis itself. Models in multi-view descriptions have a different life-cycle as they are often kept as software documentation or for requirements traceability. 
\item Moreover, semantic and analysis-driven synthesis is derivative by nature whereas the completion of multi-view system descriptions may benefit from inductive synthesis processes.
\item In the former case, models are generally kept hidden from the user who has a passive role in the synthesis process. In the second case, synthesized models must generally be validated by the end-user. The latter may even play an active role in the synthesis process itself.
\end{itemize}

The core chapters of this thesis describe two particular uses of model synthesis along these axes, illustrating the above differences:
\begin{itemize}
\item Guarded high-level Message Sequence Charts (guarded hMSC) are introduced in \cite{Damas:2010, Damas:2011} to model critical processes, such as the ones involved in medical cares. Those models take the form of flowcharts made of tasks and decision nodes with guarded outgoing transitions labeled with boolean expressions on process variables. 

In this thesis, a precise trace semantics for guarded hMSC is defined in terms of labeled transition systems (LTS) \cite{Keller:1976, Magee:1999}. To achieve this, a guarded flavor of LTS is introduced as an intermediate model. Synthesis algorithms between guarded hMSC, guarded LTS and LTS are described. These algorithms allow making LTS-based model checking available to the process models with only a slight adaptation of the technique from \cite{Giannakopoulou:2003}.

\item The thesis also describes a technique that allows synthesizing agent state machines from scenarios. The language of Message Sequence Charts (MSCs) is chosen for describing system behaviors through scenarios; agent state machines are modeled through LTS. The semantics between MSC scenarios and LTS state machines follows \cite{Uchitel:2003}.

Our technique relies on grammar induction algorithms from \cite{Oncina:1992, Lang:1998}. In addition to the synthesis of state machines from scenarios itself, an interactive feature completes the initial collection of scenarios with additional examples and counter-examples of system behavior. Moreover, domain knowledge such as goals or models of legacy components may be taken into account to ensure the consistency of the synthesized models while speeding-up the induction process.
\end{itemize}
