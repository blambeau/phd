Models are increasingly recognized as an effective means for elaborating requirements and exploring designs of software systems. A model is an abstract representation of the target system, where key features are highlighted, specified and inter-related to each other \cite{VanLamsweerde:2009}. Models are widely used at different steps of the software development process and for different software-related purposes.

%%%

\emph{Requirements engineering} for example, aims at deciding precisely what the system should do. It has been claimed that this is the hardest part of software development \cite{Brooks:1987}. Using models for exploring and stating requirements has multiple benefits:

\begin{itemize}
\item They force stakeholders and analysts to be more precise in their system description.
\item They allow them to abstract from multiple details in order to focus on key system aspects.
\item They provide a basis for early detection and fixing of errors.
\end{itemize}

Model-oriented approaches to system requirements include KAOS \cite{VanLamsweerde:2009} and NFR/i$^*$ \cite{Mylopoulos:1992, Yu:1993}. Models explain how system objectives may be refined in lower-level objectives, also called goals. KAOS emphasizes more on semi-formal and formal reasoning about behavioural goals, i.e. goals that prescribe system behaviors declaratively. In NFR/i$^*$, the emphasis is more on qualitative reasoning on soft goals, i.e. goals that cannot be established in a clear-cut sense.

%%%

\emph{Software design} may be captured by Model Driven Engineering (MDE) approaches and driven by UML models \cite{OMG:2004} and Domain Specific Languages \cite{VanDeursen:2000, Fowler:2010}. Such approaches model the application domain rather than the computing or algorithmic concepts. The use of models here has several advantages:

\begin{itemize}
\item They enforce the separation between the abstract domain concepts and their concrete implementation. This allows focusing on each aspect at the adequate level of abstraction.
\item Code fragments can often be generated from models, which is less error-prone and time consuming than manually translating models to code. In the case of domain specific languages, models may even be truly executable already. 
\item Design models also yield a natural documentation for the software and the underlying design decisions. 
\end{itemize}

%%%

\emph{Work processes} may be represented by different graphical models. Such models take different forms: flowchart style, e.g. Activity Diagrams \cite{OMG:2004} or Business Process Modeling Notation (BPMN) \cite{OMG:2008}, task trees, e.g. Little-Jil \cite{Clarke:2008}. Such models may be limited to graphical representations, e.g. Activity Diagrams and BPMN or have a strong formal semantics, e.g. Little-Jil and YAWL \cite{Vanderaalst:2005}. These approaches allow:

\begin{itemize}
\item Analyzing and verifying models before translating them to work organization on the field. This allows early detecting errors and bottlenecks, among others.
\item Partly or fully triggering the execution of necessary tasks, through reminders to process actors or automated processing for example.
\end{itemize}

%%%

Complex systems are better described with multiple views, each of them being captured through a specific kind of model. Such models focus on particular facets of the system, i.e. its intentional, structural, operational and behavioral dimensions. Scenarios, for example, illustrate interactions between agents forming the system whereas goals make the underlying objectives precise. Models often overlap on specific aspects of their system descriptions. For example, the agents forming the system appear both in scenarios and in a goal model.

Reaching quality models in such multi-view approaches is far from an easy task. Adequate modeling languages, tools and techniques are therefore required to help building them. To play a significant role, a good multi-view modeling language should meet the following requirements \cite{VanLamsweerde:2009}:

\begin{itemize}
\item \emph{Multi-level}: the system should be captured at different levels of abstraction and precision to enable stepwise elaboration and validation;
\item \emph{Analyzable}: the modeling abstractions should be accurate enough to support useful forms of analysis.
\end{itemize}

In addition, such modeling language should support stakeholders and analysts in building quality models. A ``good'' model should meet the following requirements \cite{VanLamsweerde:2009}:

\begin{itemize}
\item \emph{Adequate}: the models should adequately represent the essence of the target system while abstracting unnecessary details;
\item \emph{Complete}: the models should capture all pertinent facets of the system along the \textsc{why-}, \textsc{what-} and \textsc{how-} dimensions;
\item \emph{Precise}: the models should be accurate enough to capture system descriptions with as less ambiguity as possible;
\item \emph{Consistent}: the models should agree on their overlapping descriptions of the system;
\item \emph{Comprehensible}: the models should be easy enough to understand by the people who need to use them;
\end{itemize}

Formal modeling approaches help meeting the requirements above. The semantics of a formal modeling language provides precise rules of interpretation that allow many of the problems with natural language to be overcome. Formal specifications may also be manipulated by automated tools for a wide variety of purposes. Among them, model \emph{analysis} and model \emph{synthesis} are intertwined activities that help reaching quality models, mostly along completeness, consistency  and precision.

\begin{description}

\item[Model analysis] may be done at surface level, e.g. by query-based checks on model \cite{VanLamsweerde:2009}, or more deeply according to different types of approaches, such as model-checking \cite{Clarke:1986, Queille:1982}. For example, model analysis may be used:

\begin{itemize}
\item to detect inconsistencies between different system views;
\item to complete system descriptions, using examples and counter-example returned by queries and checks to trigger new model construction;
\item to gain modeling precision and accuracy by incrementally refining models as the result of analysis feedback;
\end{itemize}

\item[Model synthesis] helps creating and completing models thanks to multiple sources of knowledge. Among others, model synthesis may be used:

\begin{itemize}
\item to complete a multi-view description by synthesizing missing models or completing existing ones;
\item to define the operational semantics of high-level models through their rewriting as lower-level ones;
\item to make analyses available at a high-level of system description that were available at those lower-levels;
\end{itemize}

\end{description}

In practice, the boundaries between model synthesis and model analysis are a bit fuzzy. As stated above, model synthesis helps making model analysis available; on the other hand, feedback of analyses may actually yield models and can thus be seen as a kind of model synthesis. Be that as it may, the thesis investigates model synthesis more specifically; its companion by Christophe Damas \cite{Damas:2011} investigates model analysis. Both report research efforts on the same kind of models: scenarios, state machines, goals and processes.


